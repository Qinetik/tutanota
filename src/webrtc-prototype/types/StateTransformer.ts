import { EditorState, Transaction } from "prosemirror-state"
import { CRDTDocument, CRDTPos, CRDTTransaction, DeleteOperation, InsertOperation, Operation, OperationType } from "./CRDTDocument.js"
import { Fragment, Slice } from "prosemirror-model"
import { ReplaceStep } from "prosemirror-transform"
import { TextContent } from "./Algorithm.js"

/**
 * Calculates a Position within the CRDT Document corresponding to a given Prosemirror Position.
 * We do this by calculating the exact Array that the Index will be in. To do that, we
 * calculate the greatest possible Index for each Array. If the greatest Array covers
 * the one we are looking for (Prosemirror pos), then we return an Object with the Index
 * of the Array, and the actual position. We have to account for tags (-2) and the fact that
 * Prosemirror begins its position-index at 1 (-1).
 * @param pos absolute Prosemirror position
 * @param doc CRDT Document
 */
export function getCRDTPosFromProsemirrorPos(pos: number, doc: CRDTDocument): CRDTPos {
	const data = doc.getArrayRepresentation()
	let index = pos
	let arrIndex = 0
	for (let i = 0; i < data.length - 1; i++) {
		if (i == 0) index-- // decrement once to account for offset of 1 from Prosemirror Position
		index -= 2
		let greatestIndex = data[i].length - 1
		if ((greatestIndex) < index) {
			arrIndex++
			index -= greatestIndex
		} else {
			break
		}
	}

	return { array: arrIndex, index: index }
}

/**
 * Calculates a Position within the Prosemirror document corresponding to a given CRDTPos Object.
 * We do this by calculating the range of index covered by the current array-depth,
 * and then summing up the amount of characters per Array. This way we get an absolute
 * index for the position in the Prosemirror document. We also have to account
 * for offsets generated by tags within the Prosemirror document.
 * @param pos Position in the CRDT Document
 * @param doc CRDT Document
 */
export function getProsemirrorPosFromCRDTPos(pos: CRDTPos, doc: CRDTDocument): number {
	const data = doc.getArrayRepresentation()
	let index = 0
	for (let i = 0; i < pos.array; i++) {
		index += data[i].length + 2 // +2 to account for tags
		if (i == 0) index-- // -1 to account for first line not having two tags but one
	}
	index += pos.index + 2
	return index
}

export function applyCRDTTransactionToProsemirrorState(state: EditorState, tr: CRDTTransaction, doc: CRDTDocument): Transaction {
	let transaction = state.tr
	for (const op of tr.ops) {
		switch (op.type) {
			case OperationType.INSERT: {
				const operation: InsertOperation = op as InsertOperation
				const pmpos = getProsemirrorPosFromCRDTPos(operation.position, doc)
				transaction.replace(
					pmpos,
					pmpos,
					new Slice(
						Fragment.from(doc.getSchema().text(operation.content.data)),
						0,
						0
					)
				)
				break
			}

			case OperationType.DELETE: {
				const operation: DeleteOperation = op as DeleteOperation
				const pmFrom = getProsemirrorPosFromCRDTPos(operation.position.from, doc)
				const pmTo = getProsemirrorPosFromCRDTPos(operation.position.to, doc)
				transaction.replace(
					pmFrom,
					pmTo,
					new Slice(
						Fragment.from(doc.getSchema().text("")),
						0,
						0
					)
				)
				break
			}
		}
	}
	return transaction
}

export function applyProsemirrorTransactionToCRDTDocumentState(tr: Transaction, doc: CRDTDocument): CRDTTransaction | null {
	const operations: Array<Operation> = []

	for (const step of tr.steps) {
		if (step instanceof ReplaceStep) {
			if (step.slice) {
				if (step.from !== step.to) {
					const crdtFrom = getCRDTPosFromProsemirrorPos(step.from, doc)
					const crdtTo = getCRDTPosFromProsemirrorPos(step.to, doc)
					const op = new DeleteOperation(crdtFrom, crdtTo)
					operations.push(op)
				}

				const content = step.slice.content.textBetween(0, step.slice.content.size)
				const crdtContent = new TextContent("id", content, false, null, null, null)

				const op = new InsertOperation(crdtContent, getCRDTPosFromProsemirrorPos(step.from, doc))
				operations.push(op)
			} else {
				const crdtFrom = getCRDTPosFromProsemirrorPos(step.from, doc)
				const crdtTo = getCRDTPosFromProsemirrorPos(step.to, doc)
				const op = new DeleteOperation(crdtFrom, crdtTo)
				operations.push(op)
			}
		}
	}

	if (operations.length > 0) {
		return doc.createTransactionFromOperations(operations)
	} else {
		return null
	}
}