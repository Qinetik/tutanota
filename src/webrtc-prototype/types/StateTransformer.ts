import { AllSelection, EditorState, Transaction } from "prosemirror-state"
import { CRDTDocument, CRDTPos, CRDTTransaction, DeleteOperation, InsertNodeOperation, InsertOperation, Operation, OperationType } from "./CRDTDocument.js"
import { Fragment, Slice } from "prosemirror-model"
import { ReplaceStep } from "prosemirror-transform"
import { TextContent } from "./Algorithm.js"

/**
 * Calculates a Position within the CRDT Document corresponding to a given Prosemirror Position.
 * We do this by calculating the exact Array that the Index will be in. To do that, we
 * calculate the greatest possible Index for each Array. If the greatest Array covers
 * the one we are looking for (Prosemirror pos), then we return an Object with the Index
 * of the Array, and the actual position. We have to account for tags (-2) and the fact that
 * Prosemirror begins its position-index at 1 (-1).
 * @param pos absolute Prosemirror position
 * @param doc CRDT Document
 */
export function getCRDTPosFromProsemirrorPos(pos: number, doc: CRDTDocument): CRDTPos {
	const data = doc.getArrayRepresentation()
	let index = pos
	let arrIndex = 0
	for (let i = 0; arrIndex < data.length; i++) {
		// if (i == 0)
		// 	index-- // decrement once to account for offset of 1 from Prosemirror Position
		// if (arrIndex > 0) {
		index = clamp(index - 1, index, 0)
		// }
		let greatestIndex = clamp(data[i].length - 1, data[i].length, 0)
		if (greatestIndex == index - 1) { // this means we are trying to add to the end of a paragraph, but not the next one.
			return { array: arrIndex, index: index }
		} else if (greatestIndex < index) {
			arrIndex++
			index -= greatestIndex - 2
		} else {
			// index = clamp(index, clamp(data[i].length - 1, data[i].length, 0), 0)
			break
		}
	}

	return { array: arrIndex, index: index }
}

/**
 * "Clamps" a given number between an upper and lower bound. Example:
 * clamp(10, 5, 0) = 5
 * clamp(10-100, 10, -10) = -5
 * clamp(10-5, 10, 0) = 5
 *
 * @param num Number to clamp
 * @param upper Upper bound
 * @param lower Lower bound
 */
function clamp(num: number, upper: number, lower: number): number {
	return num < upper
		? num > lower
			? num
			: lower
		: upper
}

/**
 * Calculates a Position within the Prosemirror document corresponding to a given CRDTPos Object.
 * We do this by calculating the range of index covered by the current array-depth,
 * and then summing up the amount of characters per Array. This way we get an absolute
 * index for the position in the Prosemirror document. We also have to account
 * for offsets generated by tags within the Prosemirror document.
 * @param pos Position in the CRDT Document
 * @param doc CRDT Document
 */
export function getProsemirrorPosFromCRDTPos(pos: CRDTPos, doc: CRDTDocument): number {
	const data = doc.getArrayRepresentation()
	let index = 0
	for (let i = 0; i < pos.array; i++) {
		index += data[i].length + 1 // +1 to account for tags
		if (i == 0) index-- // -1 to account for first line not having two tags but one
	}
	index += pos.index + 1 /* + 2 */
	return index
}

export function applyCRDTTransactionToProsemirrorState(state: EditorState, tr: CRDTTransaction, doc: CRDTDocument): Transaction {
	let transaction = state.tr
	for (const op of tr.ops) {
		switch (op.type) {
			case OperationType.INSERT: {
				const operation: InsertOperation = op as InsertOperation
				const pmpos = getProsemirrorPosFromCRDTPos(operation.position, doc)
				transaction.replace(
					pmpos,
					pmpos,
					new Slice(
						Fragment.from(doc.getSchema().text(operation.content.data)),
						0,
						0
					)
				)
				break
			}

			case OperationType.INSERT_NODE: {
				const operation: InsertNodeOperation = op as InsertNodeOperation
				const contents: String[] = []
				operation.content.forEach(c => {
					contents.push(c.data)
				})
				const content = contents.join(" ") // forms a sentence from all Contents
				const pmpos = getProsemirrorPosFromCRDTPos(operation.position, doc)
				transaction.split(pmpos)
				// transaction.replace(
				// 	pmpos,
				// 	pmpos,
				// 	new Slice(
				// 		Fragment.from(doc.getSchema().node("paragraph", null,
				// 			doc.schema.text(content))), 0, 0
				// 	)
				// )
				break
			}

			case OperationType.DELETE: {
				const operation: DeleteOperation = op as DeleteOperation
				const pmFrom = getProsemirrorPosFromCRDTPos(operation.position.from, doc)
				const pmTo = getProsemirrorPosFromCRDTPos(operation.position.to, doc)
				transaction.replace(
					pmFrom,
					pmTo,
					Slice.empty
				)
				break
			}
		}
	}
	return transaction
}

export function applyProsemirrorTransactionToCRDTDocumentState(tr: Transaction, doc: CRDTDocument): CRDTTransaction | null {
	const operations: Array<Operation> = []

	for (const step of tr.steps) {
		if (step instanceof ReplaceStep) {
			if (step.slice) {

				// this means that there are nodes being inserted
				// if (step.slice.content.size > 1) {
				// 	const pos = getCRDTPosFromProsemirrorPos(step.from, doc)
				//
				// 	const array = doc.getArrayRepresentation()[pos.array]
				//
				// 	// Inserting a new Node means that we are either line breaking
				// 	// somewhere in the paragraph, or at the end. No matter what, we can splice
				// 	// the contents from the index at which we want to insert the node, take all the
				// 	// content that comes after it and insert it in a new node (array).
				// 	// splice() returns the elements that we removed.
				// 	const content = array.splice(pos.index, array.length)
				// 	const op = new InsertNodeOperation(content, pos)
				// 	operations.push(op)
				//
				// 	// TODO
				// 	//  This only takes care of a singular node though, we might have more being
				// 	//  inserted, e.g. if someone copies and pastes multiple nodes.
				// }


				if (step.from !== step.to) {
					const crdtFrom = getCRDTPosFromProsemirrorPos(step.from, doc)
					let crdtTo

					// if step.from == 0, then the text has been selected using ctrl + A, which
					// creates a different selection than selecting the entire paragraph manually.
					// The selection then starts at 0 and spans until paragraph.size+1, whereas usually
					// it only spans from 1 to paragraph.size. We have to account for this manually, as
					// otherwise it produces an error with our CRDTPos calculation.
					if (step.from == 0) {
						crdtTo = getCRDTPosFromProsemirrorPos(step.to - 1, doc)
					} else {
						crdtTo = getCRDTPosFromProsemirrorPos(step.to, doc)
					}
					const op = new DeleteOperation(crdtFrom, crdtTo)
					doc.delete(op.position.from, op.position.to)
					operations.push(op)
				}

				const content = step.slice.content.textBetween(0, step.slice.content.size)
				if (content !== "") {
					let index = step.from
					for (const str of content.split("")) {
						const crdtContent = new TextContent("id", str, false, null, null, null)
						const op = new InsertOperation(crdtContent, getCRDTPosFromProsemirrorPos(index, doc))
						doc.insert(op.position, op.content)
						operations.push(op)
						index++
					}
				}
			} else {
				const crdtFrom = getCRDTPosFromProsemirrorPos(step.from, doc)
				const crdtTo = getCRDTPosFromProsemirrorPos(step.to, doc)
				const op = new DeleteOperation(crdtFrom, crdtTo)
				doc.delete(op.position.from, op.position.to)
				operations.push(op)
			}
		}
	}

	if (operations.length > 0) {
		return doc.createTransactionFromOperations(operations)
	} else {
		return null
	}
}